/* eslint-disable no-console */
export const GENERAL_PROPERTIES = {
  GENERAL_GRADE: 'GENERAL_GRADE',
  GENERAL_LEVEL: 'GENERAL_LEVEL',
  GENERAL_EXP: 'GENERAL_EXP',
  GENERAL_NEXT: 'GENERAL_NEXT',
  GENERAL_ENCHANCEMENTS: 'GENERAL_ENCHANCEMENTS',
  GENERAL_ATUAL_SKILL_REGEN: 'GENERAL_ATUAL_SKILL_REGEN',
  GENERAL_MAX_SKILL_REGEN: 'GENERAL_MAX_SKILL_REGEN',
  GENERAL_JP: 'GENERAL_JP',
  GENERAL_GOLD: 'GENERAL_GOLD'
}

export const CONDITIONS_PROPERTIES = {
  CONDITIONS_ATUAL_HP: 'CONDITIONS_ATUAL_HP',
  CONDITIONS_ATUAL_MP: 'CONDITIONS_ATUAL_MP',
  CONDITIONS_ATUAL_SP: 'CONDITIONS_ATUAL_SP',
  CONDITIONS_ATUAL_HUNGER: 'CONDITIONS_ATUAL_HUNGER',
  CONDITIONS_MAX_HP: 'CONDITIONS_MAX_HP',
  CONDITIONS_MAX_MP: 'CONDITIONS_MAX_MP',
  CONDITIONS_MAX_SP: 'CONDITIONS_MAX_SP',
  CONDITIONS_MAX_HUNGER: 'CONDITIONS_MAX_HUNGER'
}

export const ATTRIBUTES_PROPERTIES = {
  ATTRIBUTES_STRENGTH: 'ATTRIBUTES_STRENGTH',
  ATTRIBUTES_AGILITY: 'ATTRIBUTES_AGILITY',
  ATTRIBUTES_DEXTERITY: 'ATTRIBUTES_DEXTERITY',
  ATTRIBUTES_VITALITY: 'ATTRIBUTES_VITALITY',
  ATTRIBUTES_SPIRIT: 'ATTRIBUTES_SPIRIT',
  ATTRIBUTES_LUCK: 'ATTRIBUTES_LUCK'
}

export const ATTRIBUTES_MOD_PROPERTIES = {
  ATTRIBUTES_STRENGTH_MOD: 'ATTRIBUTES_STRENGTH_MOD',
  ATTRIBUTES_AGILITY_MOD: 'ATTRIBUTES_AGILITY_MOD',
  ATTRIBUTES_DEXTERITY_MOD: 'ATTRIBUTES_DEXTERITY_MOD',
  ATTRIBUTES_VITALITY_MOD: 'ATTRIBUTES_VITALITY_MOD',
  ATTRIBUTES_SPIRIT_MOD: 'ATTRIBUTES_SPIRIT_MOD',
  ATTRIBUTES_LUCK_MOD: 'ATTRIBUTES_LUCK_MOD'
}

export const STATS_PROPERTIES = {
  STATS_INITIATIVE: 'STATS_INITIATIVE',
  STATS_DODGE: 'STATS_DODGE',
  STATS_MOVE: 'STATS_MOVE',
  STATS_CRITICAL: 'STATS_CRITICAL',
  STATS_PHYSICAL_DEFENSE: 'STATS_PHYSICAL_DEFENSE',
  STATS_PHYSICAL_DICE: 'STATS_PHYSICAL_DICE',
  STATS_MAGICAL_DEFENSE: 'STATS_MAGICAL_DEFENSE',
  STATS_MAGICAL_DICE: 'STATS_MAGICAL_DICE'
}

export const RANGE_PROPERTIES = {
  RANGE_UNARMED: 'RANGE_UNARMED',
  RANGE_MELEE: 'RANGE_MELEE',
  RANGE_RANGED: 'RANGE_RANGED',
  RANGE_FIREARM: 'RANGE_FIREARM'
}

export const HIT_PROPERTIES = {
  HIT_UNARMED: 'HIT_UNARMED',
  HIT_MELEE: 'HIT_MELEE',
  HIT_RANGED: 'HIT_RANGED',
  HIT_FIREARM: 'HIT_FIREARM'
}

export const PHYSICIAL_BONUS_PROPERTIES = {
  PHYSICIAL_BONUS_UNARMED: 'PHYSICIAL_BONUS_UNARMED',
  PHYSICIAL_BONUS_MELEE: 'PHYSICIAL_BONUS_MELEE',
  PHYSICIAL_BONUS_RANGED: 'PHYSICIAL_BONUS_RANGED',
  PHYSICIAL_BONUS_FIREARM: 'PHYSICIAL_BONUS_FIREARM'
}

export const MAGICAL_BONUS_PROPERTIES = {
  MAGICAL_BONUS_WATER: 'MAGICAL_BONUS_WATER',
  MAGICAL_BONUS_ETHEREAL: 'MAGICAL_BONUS_ETHEREAL',
  MAGICAL_BONUS_FIRE: 'MAGICAL_BONUS_FIRE',
  MAGICAL_BONUS_ICE: 'MAGICAL_BONUS_ICE',
  MAGICAL_BONUS_MOON: 'MAGICAL_BONUS_MOON',
  MAGICAL_BONUS_LIGHT: 'MAGICAL_BONUS_LIGHT',
  MAGICAL_BONUS_MAGICK: 'MAGICAL_BONUS_MAGICK',
  MAGICAL_BONUS_NATURE: 'MAGICAL_BONUS_NATURE',
  MAGICAL_BONUS_SUN: 'MAGICAL_BONUS_SUN',
  MAGICAL_BONUS_SOUL: 'MAGICAL_BONUS_SOUL',
  MAGICAL_BONUS_EARTH: 'MAGICAL_BONUS_EARTH',
  MAGICAL_BONUS_DARKNESS: 'MAGICAL_BONUS_DARKNESS',
  MAGICAL_BONUS_THUNDER: 'MAGICAL_BONUS_THUNDER',
  MAGICAL_BONUS_WIND: 'MAGICAL_BONUS_WIND'
}

export const EXPERTISE_STRENGTH_PROPERTIES = {
  EXPERTISE_MELEE_WEAPONS: 'EXPERTISE_MELEE_WEAPONS',
  EXPERTISE_MECHANICAL_WEAPONS: 'EXPERTISE_MECHANICAL_WEAPONS',
  EXPERTISE_WILLPOWER: 'EXPERTISE_WILLPOWER',
  EXPERTISE_FORGE: 'EXPERTISE_FORGE',
  EXPERTISE_IMMOBILIZATION: 'EXPERTISE_IMMOBILIZATION',
  EXPERTISE_UNARMED_COMBAT: 'EXPERTISE_UNARMED_COMBAT',
  EXPERTISE_MINING: 'EXPERTISE_MINING',
  EXPERTISE_MOUNT: 'EXPERTISE_MOUNT',
  EXPERTISE_TRACK: 'EXPERTISE_TRACK'
}

export const EXPERTISE_AGILITY_PROPERTIES = {
  EXPERTISE_MISLEAD: 'EXPERTISE_MISLEAD',
  EXPERTISE_DISGUISE: 'EXPERTISE_DISGUISE',
  EXPERTISE_DUAL_WIELD: 'EXPERTISE_DUAL_WIELD',
  EXPERTISE_HIDE: 'EXPERTISE_HIDE',
  EXPERTISE_DODGE: 'EXPERTISE_DODGE',
  EXPERTISE_ESCAPE: 'EXPERTISE_ESCAPE',
  EXPERTISE_JUMP: 'EXPERTISE_JUMP'
}

export const EXPERTISE_DEXTERITY_PROPERTIES = {
  EXPERTISE_AGRICULTURE: 'EXPERTISE_AGRICULTURE',
  EXPERTISE_RANGED_WEAPON: 'EXPERTISE_RANGED_WEAPON',
  EXPERTISE_FIREARM: 'EXPERTISE_FIREARM',
  EXPERTISE_MASONRY: 'EXPERTISE_MASONRY',
  EXPERTISE_THROW_OBJECT: 'EXPERTISE_THROW_OBJECT',
  EXPERTISE_CLIMB: 'EXPERTISE_CLIMB',
  EXPERTISE_BUILD_BOAT: 'EXPERTISE_BUILD_BOAT',
  EXPERTISE_SWIM: 'EXPERTISE_SWIM',
  EXPERTISE_PILOTING: 'EXPERTISE_PILOTING',
  EXPERTISE_SET_TRAP: 'EXPERTISE_SET_TRAP',
  EXPERTISE_FIRST_AID: 'EXPERTISE_FIRST_AID'
}

export const EXPERTISE_VITALITY_PROPERTIES = {
  EXPERTISE_CHARISMA: 'EXPERTISE_CHARISMA',
  EXPERTISE_PHYSICAL_DEFENSE: 'EXPERTISE_PHYSICAL_DEFENSE',
  EXPERTISE_LEADERSHIP: 'EXPERTISE_LEADERSHIP',
  EXPERTISE_SURVIVAL: 'EXPERTISE_SURVIVAL'
}

export const EXPERTISE_SPIRIT_PROPERTIES = {
  EXPERTISE_AID: 'EXPERTISE_AID',
  EXPERTISE_BLUFF: 'EXPERTISE_BLUFF',
  EXPERTISE_CONJURATION: 'EXPERTISE_CONJURATION',
  EXPERTISE_MAGICAL_DEFENSE: 'EXPERTISE_MAGICAL_DEFENSE',
  EXPERTISE_WATER_ELEMENT: 'EXPERTISE_WATER_ELEMENT',
  EXPERTISE_ETHEREAL_ELEMENT: 'EXPERTISE_ETHEREAL_ELEMENT',
  EXPERTISE_FIRE_ELEMENT: 'EXPERTISE_FIRE_ELEMENT',
  EXPERTISE_ICE_ELEMENT: 'EXPERTISE_ICE_ELEMENT',
  EXPERTISE_MOON_ELEMENT: 'EXPERTISE_MOON_ELEMENT',
  EXPERTISE_LIGHT_ELEMENT: 'EXPERTISE_LIGHT_ELEMENT',
  EXPERTISE_MAGICK_ELEMENT: 'EXPERTISE_MAGICK_ELEMENT',
  EXPERTISE_NATURE_ELEMENT: 'EXPERTISE_NATURE_ELEMENT',
  EXPERTISE_SUN_ELEMENT: 'EXPERTISE_SUN_ELEMENT',
  EXPERTISE_SOUL_ELEMENT: 'EXPERTISE_SOUL_ELEMENT',
  EXPERTISE_EARTH_ELEMENT: 'EXPERTISE_EARTH_ELEMENT',
  EXPERTISE_DARKNESS_ELEMENT: 'EXPERTISE_DARKNESS_ELEMENT',
  EXPERTISE_THUNDER_ELEMENT: 'EXPERTISE_THUNDER_ELEMENT',
  EXPERTISE_WIND_ELEMENT: 'EXPERTISE_WIND_ELEMENT',
  EXPERTISE_INTERPRET_DREAMS: 'EXPERTISE_INTERPRET_DREAMS',
  EXPERTISE_INTERROGATE: 'EXPERTISE_INTERROGATE',
  EXPERTISE_INTIMIDATE: 'EXPERTISE_INTIMIDATE',
  EXPERTISE_LANGUAGE: 'EXPERTISE_LANGUAGE',
  EXPERTISE_CURSE: 'EXPERTISE_CURSE',
  EXPERTISE_MYSTICISM: 'EXPERTISE_MYSTICISM',
  EXPERTISE_NEGOTIATE: 'EXPERTISE_NEGOTIATE',
  EXPERTISE_PERCEPTION: 'EXPERTISE_PERCEPTION',
  EXPERTISE_PREDICT_WEATHER: 'EXPERTISE_PREDICT_WEATHER',
  EXPERTISE_TACTICS: 'EXPERTISE_TACTICS'
}

export const EXPERTISE_LUCK_PROPERTIES = {
  EXPERTISE_CRITICAL: 'EXPERTISE_CRITICAL',
  EXPERTISE_PLAY_CALCULATE: 'EXPERTISE_PLAY_CALCULATE',
  EXPERTISE_MAGICK_FIND: 'EXPERTISE_MAGICK_FIND'
}

export const EXPERTISE_SPECIAL_PROPERTIES = {
  EXPERTISE_ASTRONOMY: 'EXPERTISE_ASTRONOMY',
  EXPERTISE_ACROBATICS: 'EXPERTISE_ACROBATICS',
  EXPERTISE_STEAL: 'EXPERTISE_STEAL',
  EXPERTISE_CHEMISTRY: 'EXPERTISE_CHEMISTRY',
  EXPERTISE_RELAXATION: 'EXPERTISE_RELAXATION',
  EXPERTISE_FAITH: 'EXPERTISE_FAITH',
  EXPERTISE_SPECIAL_WEAPON: 'EXPERTISE_SPECIAL_WEAPON',
  EXPERTISE_COMBO: 'EXPERTISE_COMBO',
  EXPERTISE_MVP: 'EXPERTISE_MVP',
  EXPERTISE_PVP: 'EXPERTISE_PVP',
  EXPERTISE_SYNERGY: 'EXPERTISE_SYNERGY'
}

export const EXPERTISE_PROPERTIES = {
  ...EXPERTISE_STRENGTH_PROPERTIES,
  ...EXPERTISE_AGILITY_PROPERTIES,
  ...EXPERTISE_DEXTERITY_PROPERTIES,
  ...EXPERTISE_VITALITY_PROPERTIES,
  ...EXPERTISE_SPIRIT_PROPERTIES,
  ...EXPERTISE_LUCK_PROPERTIES,
  ...EXPERTISE_SPECIAL_PROPERTIES
}

export const ALL_PROPERTIES = {
  ...GENERAL_PROPERTIES,
  ...CONDITIONS_PROPERTIES,
  ...ATTRIBUTES_PROPERTIES,
  ...ATTRIBUTES_MOD_PROPERTIES,
  ...STATS_PROPERTIES,
  ...RANGE_PROPERTIES,
  ...HIT_PROPERTIES,
  ...PHYSICIAL_BONUS_PROPERTIES,
  ...MAGICAL_BONUS_PROPERTIES,
  ...EXPERTISE_PROPERTIES
}

export type AllPropertiesTypes = typeof ALL_PROPERTIES[keyof typeof ALL_PROPERTIES];

export enum OperationAction {
  SUM = 'SUM',
  SUBTRACTION = 'SUBTRACTION',
  MULTIPLICATION = 'MULTIPLICATION',
  DIVISION = 'DIVISION',
}

export interface IBasedOnOperation {
  type: AllPropertiesTypes
  modifyProperty: boolean
  modifierAction?: OperationAction
  modifierValue?: number
}

export interface IOperation {
  id: string
  target: AllPropertiesTypes
  action: OperationAction
  baseFormula?: boolean
  baseValue?: boolean
  description?: string
  isBasedOnProperty?: boolean
  isPercentage?: boolean
  isSubstitution?: boolean
  value?: number
  basedOnProperty?: IBasedOnOperation
  substitutionPriority?: number
}

export interface IProperty {
  type: AllPropertiesTypes
  operations: IOperation[]
}

export interface IElement {
  type: string,
  advantage?: {
    type: string
    value: string
  },
  disadvantage?: {
    type: string
    value: string
  },
  description?: string
}

export interface IJob {
  type: string,
  tier: number,
  description?: string
}

export class Character {
  // eslint-disable-next-line no-useless-constructor
  constructor (
    public id: string,
    public player: string,
    public name: string,
    public guild: string,
    public elements: IElement[],
    public jobs: IJob[],
    public operations: IOperation[],
    public readonly version = Character.currentVersion
  ) {}

  static readonly currentVersion = '0.0.1'

  static fromMap (map: Character | Record<string, unknown>) {
    return new Character(
      map.id as string,
      map.player as string,
      map.name as string,
      map.guild as string,
      map.elements as IElement[],
      map.jobs as IJob[],
      map.operations as IOperation[],
      map.version as string
    )
  }

  toMap (): Omit<Character,
  | 'currentVersion'
  | 'toMap'
  | 'getProperty'
  | 'checkForCircularDependency'
  | 'checkIfOperationIsBasedOnProperty'
  | 'checkIfPropertyBasedOperationHasModifiers'
  > {
    return {
      id: this.id,
      player: this.player,
      name: this.name,
      guild: this.guild,
      elements: this.elements,
      jobs: this.jobs,
      operations: this.operations,
      version: this.version
    }
  }

  getProperty (propertyType: AllPropertiesTypes, propertyTypesStack?: AllPropertiesTypes[]): number {
    try {
      // Check for circular dependencies between types.
      const updatedTypesStack = this.checkForCircularDependency(propertyType, propertyTypesStack)
      // Get the list of operations that have the given propertyType as Its target.
      const operations = this.operations.filter(operation => operation.target === propertyType)
      if (operations.length) {
        // Get list of substitutions operations and sort them based on priority.
        // If no priority is present on a given operation, set It as 0.
        // Return the highes priority operation as the returning value.
        const substitutionOperations = operations.filter(operation => operation.isSubstitution)
        if (substitutionOperations.length) {
          const withMinimumPriority = substitutionOperations.map((operation) => {
            if (typeof operation.substitutionPriority !== 'number') {
              operation.substitutionPriority = 0
            }
            return operation
          })
          const highestPriority = withMinimumPriority.reduce((max, current) => {
            return current.substitutionPriority! > max.substitutionPriority! ? current : max
          }, substitutionOperations[0])
          return highestPriority.value ?? 1
        }
        // Placeholder that will holde the final value to be returned.
        let finalValue = 0
        // Get list of arithmetic operations that are not percentages or substitutions and execute them in order.
        const arithmeticsOperations = operations.filter(operation => !operation.isPercentage && !operation.isSubstitution)
        if (arithmeticsOperations.length) {
          arithmeticsOperations
            .filter(operation => operation.action === OperationAction.SUM)
            .forEach((operation) => {
              const valueToUse = this.checkIfOperationIsBasedOnProperty(operation, updatedTypesStack)
              finalValue += valueToUse
            })
          arithmeticsOperations
            .filter(operation => operation.action === OperationAction.SUBTRACTION)
            .forEach((operation) => {
              const valueToUse = this.checkIfOperationIsBasedOnProperty(operation, updatedTypesStack)
              finalValue -= valueToUse
              if (finalValue <= 0) {
                finalValue = 1
              }
            })
          arithmeticsOperations
            .filter(operation => operation.action === OperationAction.MULTIPLICATION)
            .forEach((operation) => {
              const valueToUse = this.checkIfOperationIsBasedOnProperty(operation, updatedTypesStack)
              finalValue *= valueToUse > 0 ? valueToUse : 1
            })
          arithmeticsOperations
            .filter(operation => operation.action === OperationAction.DIVISION)
            .forEach((operation) => {
              const valueToUse = this.checkIfOperationIsBasedOnProperty(operation, updatedTypesStack)
              finalValue /= valueToUse > 0 ? valueToUse : 1
            })
        }
        // Get list of percentage operations and execute them.
        const percentageOperations = operations.filter(operation => operation.isPercentage && operation.action && [OperationAction.SUM, OperationAction.SUBTRACTION].includes(operation.action))
        if (percentageOperations.length) {
          const finalPercentage = percentageOperations.reduce((accumulator, operation) => {
            const valueToUse = this.checkIfOperationIsBasedOnProperty(operation, updatedTypesStack)
            return operation.action === OperationAction.SUM ? accumulator + valueToUse : accumulator - valueToUse
          }, 0)
          const percentageValue = finalValue * (finalPercentage / 100)
          finalValue += percentageValue
          if (finalValue <= 0) {
            finalValue = 1
          }
        }
        if (![...Object.values(GENERAL_PROPERTIES), ...Object.values(CONDITIONS_PROPERTIES)].includes(propertyType)) {
          if (Math.floor(finalValue) <= 0) {
            finalValue = 1
          }
        }
        return Math.floor(finalValue)
      }
      // Return 1 if there are no operation for the propertyType.
      return 1
    } catch (error) {
      console.log(error)
      // Return 1 if an error occured (like a circular dependency).
      return 1
    }
  }

  // Given a propertyType and a propertytypesStack, check if the type already exists in the stack.
  // If it exists, throw an error.
  // Else, return an updated stack with the provided type included.
  checkForCircularDependency (propertyType: AllPropertiesTypes, propertyTypesStack?: AllPropertiesTypes[]) {
    if (propertyTypesStack?.length && propertyTypesStack.includes(propertyType)) {
      alert('oof')
      throw new Error(`${propertyType} was already in the operation stack, circular operations not permitted.`)
    }
    return propertyTypesStack?.length ? [...propertyTypesStack, propertyType] : [propertyType]
  }

  // Check if an operation is based on another property, and retrive Its valu if so.
  // Else, just return the absolute value or 0.
  checkIfOperationIsBasedOnProperty (operation: IOperation, propertyTypesStack?: AllPropertiesTypes[]) {
    let valueToUse = 0
    if (operation.isBasedOnProperty && operation.basedOnProperty) {
      valueToUse = this.checkIfPropertyBasedOperationHasModifiers(operation.basedOnProperty, propertyTypesStack)
    } else if (typeof operation.value === 'number') {
      valueToUse = operation.value
    }
    return valueToUse
  }

  // Check if an operations which is based on another property has modifiers, if so, execute them before returning the value.
  checkIfPropertyBasedOperationHasModifiers (based: IBasedOnOperation, recursingTypes?: AllPropertiesTypes[]) {
    let valueToUse = this.getProperty(based.type, recursingTypes)
    if (based.modifyProperty && typeof based.modifierValue === 'number') {
      switch (based.modifierAction) {
        case OperationAction.SUM:
          valueToUse += based.modifierValue
          break
        case OperationAction.SUBTRACTION:
          valueToUse -= based.modifierValue
          break
        case OperationAction.MULTIPLICATION:
          valueToUse *= based.modifierValue > 0 ? based.modifierValue : 1
          break
        case OperationAction.DIVISION:
          valueToUse /= based.modifierValue > 0 ? based.modifierValue : 1
          break
        default:
          break
      }
    }
    return valueToUse >= 0 ? valueToUse : 0
  }
}

export const ELEMENTS_LIST: IElement[] = [
  {
    type: 'fire',
    advantage: {
      type: 'nature',
      value: '25'
    },
    disadvantage: {
      type: 'water',
      value: '25'
    }
  },
  {
    type: 'nature',
    advantage: {
      type: 'ice',
      value: '25'
    },
    disadvantage: {
      type: 'fire',
      value: '25'
    }
  },
  {
    type: 'wind',
    advantage: {
      type: 'earth',
      value: '25'
    },
    disadvantage: {
      type: 'nature',
      value: '25'
    }
  },
  {
    type: 'earth',
    advantage: {
      type: 'thunder',
      value: '25'
    },
    disadvantage: {
      type: 'wind',
      value: '25'
    }
  },
  {
    type: 'thunder',
    advantage: {
      type: 'water',
      value: '25'
    },
    disadvantage: {
      type: 'earth',
      value: '25'
    }
  },
  {
    type: 'water',
    advantage: {
      type: 'fire',
      value: '25'
    },
    disadvantage: {
      type: 'thunder',
      value: '25'
    }
  }
]

export const JOBS_LIST: IJob[] = [
  {
    type: 'acolyte',
    tier: 1
  },
  {
    type: 'archer',
    tier: 1
  },
  {
    type: 'mage',
    tier: 1
  },
  {
    type: 'merchant',
    tier: 1
  },
  {
    type: 'swordsman',
    tier: 1
  },
  {
    type: 'thief',
    tier: 1
  }
]
